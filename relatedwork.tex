\section{Related Work}\label{sec:RW}

% \Qt{Suggestion: I do not think we should include coverage numbers of projects that do not support direct semantics. And here are the reasons:
%     1. Projects like angr or mcsema do have support  of x87 or mmx which we do not have. That way if we include 
%     x87/mmx in the total instructions count we cannot say that we are 100\%.
%     2. Now if we exclude x87/mmx instructions and give the percentage (and that way we can say we are 100\%), but  that may confuse people. 
% 
%     We can include Strata and Goel's work in the table (or write in text ) and *can* include the percentages because neither of them support x87/mmx. For the others we can argue that they are not direct. Also we may 
%     add that bap, remill and radare2 are not complete. I can later will in what exact instruction they are missing  
%  }
% 
% \Qd{\revisit{I think we should ommit exact percentage numbers all together in the table. We should replace that column with a simple yes/no checkmark whether the semantics is complete. Also remove all together projects that do not give semantics directly to x86 but to some IL.}}

There have been many projects that host a formal semantics of \ISA either as
their main contribution or as part of their infrastructure.
Table~\ref{table:RW} summarizes such previous work and compares it to our formal semantics.\footnote{Here we focus on comparing with other \emph{direct} semantics, since a complete \emph{direct} semantics is our goal and required for our purpose. We will discuss other \emph{indirect} semantics later in this section.}
We do the comparison in three directions that reflect the
primary contributions of our work: the completeness of the definition in terms
of supported user-level instructions, the faithfulness of the definition in
terms of whether it is executable and hence can be evaluated with real code
execution, and the generality of the definition in terms of its applicability to
formal reasoning analyses. Next, we discuss in more detail each of the
related works.


\begin{table}
\scalebox{0.7}{
%\setlength{\arrayrulewidth}{.15em} 
\begin{tabular}{l||ccc}
\hline
\\ [-10pt]
\multicolumn{1}{l||}{\begin{tabular}[]{@{}c@{}}Project \\ Name\end{tabular}} & 
\multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}Complete Support of \\ \ISA User-Level \\ Instructions (in scope) \end{tabular}} &
\multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}Executable \\ Semantics\end{tabular}} &
\multicolumn{1}{c}{\begin{tabular}[c]{@{}c@{}}Support for \\ Full-Fledged \\ Formal Reasoning\end{tabular}} \\
\hline 
\\ [-10pt]
Strata~\cite{Heule2016a}          & \xmark & \rating{50} & \xmark      \\
Goel et. al.~\cite{Goel:FMCAD14}  & \xmark & \cmark      & \cmark      \\
CompCert~\cite{Leroy:2009}        & \xmark & \cmark      & \cmark      \\
Remill~\cite{Remill}              & \xmark & \cmark      & \xmark      \\
TSL~\cite{TSL:TOPLAS13}           & \xmark & \cmark      & \rating{50} \\
\hline
\textbf{Our Semantics}            & \cmark & \cmark      & \cmark      \\
\hline
\end{tabular}}
\begin{center} 
{\small
    \cmark : Yes
    \quad
    \xmark : No % due to incorrect semantics
    \quad
    \rating{50} : Partially True
    \hfill
    %\quad
    %\emph{NJ}: Node.js 0.10.29
}
\end{center}
\caption{Projects hosting formal semantics of the \ISA ISA.}
\label{table:RW}
\end{table}

\Strata~\cite{Heule2016a} uses program synthesis to generate the instruction
semantics, as SMT bit-vector formulas, by learning their input/output behavior
through execution on an actual processor. \Strata's semantics definition for
\ISA is incomplete as it does not include semantics of about 40\% of the
user-level instructions in scope that are not straightforward to automatically learn by the presented algorithm for various reasons (see Section~\ref{sec:Approach:Overview} for details). Even then,
the result that the formal semantics of 60\% of the target \ISA ISA can be learned automatically
is impressive, and we leverage this result in our work as described in
section~\ref{sec:harvestsema}.
The specifications are executable only for non floating-point (FP) instructions.
The FP operations are represented in the SMT formulas of the definition as
uninterpreted functions. Finally the specifications are given as SMT formulas
but have not been demonstrated to be usable in a formal analysis setting out-of-the-box.

Goel \etal~\cite{Goel:FMCAD14} use the ACL2 theorem prover~\cite{ACL2:Kaufmann2000} to model the \ISA ISA and has support for
\goelPerc{} of all user level instructions~\cite{GoelList}. They have specifications of a selection
of user-level instructions, some system-level instructions, paging, and
segmentation. This list is far from a complete semantic definition of \ISA,
however it is still the state-of-the-art in terms of formal analysis applied
directly to \ISA code. It is also an executable definition as demonstrated in
its use for simulations. In our work we do not leverage this definition, since
we found a more complete definition such as \Strata to be a better starting
point towards completeness.

The CompCert verified compiler~\cite{Leroy:2009} includes semantics
definitions for all intermediate and target languages used within the compiler,
including a definition for x86 assembly. The definition is specified in Coq~\cite{Coq}, and has been used in a formal
setting for proving the correctness of the CompCert's compilation step to assembly,
as well as outside CompCert, e.g., in proofs relating to the certified concurrent
OS kernel CeriKOS~\cite{Gu:2016}. However, this definition focuses on the
32-bit x86 instruction set, which is a small subset of the \ISA instruction 
set.
Moreover, it is part of the trust base for CompCert and it is not clear
whether or how it has been tested against an actual processor, whereas
\Strata and ours have been extensively tested.

Remill~\cite{McSema:Recon14} is a static binary translator from \ISA to LLVM
IR~\cite{LLVM:CGO04}. The translator contains specifications for \ISA instructions
in the form of equivalent C\cmt{LLVM IR} programs to assist the translation. This
specification is neither complete nor formal and cannot be easily used
in formal analysis.

TSL~\cite{TSL:TOPLAS13} is a system that can auto-generate tools for
various machine code analyses given a semantics definition of the machine
language written in the TSL specification. Such a semantics
definition for the integer instructions (i.e., no floating-point instructions) of the $32$-bit x86 instruction set is given
as part of the project. It is used for the generation of
various tools, including a machine code synthesizer~\cite{Srinivasan2015}.
This definition, to the best of our knowledge, have not been used
for formal specification proofs, i.e., to prove whether a given x86
program meets its specification.

Our semantics, like all of the aforementioned works, uses a sequential consistency memory model, omitting weaker memory models.
Existing efforts to specify weaker memory models for \ISA such as Owens et al.~\cite{Owens:x86-TSO} and Sarkar et al.~\cite{Sarkar:POPL09} can be incorporated into ours to reason about multi-threaded programs. \Added{Moreover, the fact that they support a small $32$-bit x86 instruction set raises the potential of the usability  of such an integration towards reasoning about real world programs.}

There are various binary analysis projects that target \ISA binaries
and lift them to a higher-level representation more suitable for the
specific analysis. These include Angr~\cite{Angr} using the VEX IR of Valgrind~\cite{Valgrind:ENTCS03}, the QEMU~\cite{QEMU:USENIX05} emulator
using the TCG IR, the software fault isolation tool RockSalt~\cite{Roclsalt:PLDI12} using its own RTL DSL, the disassembler and binary analyzer Radare2~\cite{Radare2} using the ESIL IR~\cite{ESIL}, and the binary analysis
tool BAP~\cite{BAP:CAV11} using the BIL IR.
We refer these semantics as \emph{indirect} as they give the semantics of the \ISA binary via the translation to their IR, as opposed to the \emph{direct} semantics such as ours.
% because in all these cases the lifted IR, that is being analyzed, is rigorously defined as opposed to providing \emph{direct} semantics to the binary.
Note that the direct semantics has its own value.
For example, without the direct semantics of \ISA, we cannot even formulate the correctness of a translator from \ISA to the IR.
Analogously, many programming languages (C, C++, Java, etc.) have been given direct semantics, instead of indirect semantics by translation to other languages, for formal reasoning at the desired language granularity. 

% Even though tools like BAP and Angr can do some formal reasoning owing to their capability of symbolically executing the IR semantics, but they are not designed with the goal of full-fledged formal reasoning.




\cmt{ 
Regarding the comparison with previous work, we focused on comparing with other direct semantics, since a complete *direct* semantics is our goal and required for our purpose.

In all these
cases the IR that is being analyzed is rigorously defined, but we refrain from
considering these as formal specifications of \ISA because the
actually specified language has abstracted away various features of \ISA.
For example, both VEX IR and RockSalt use different simplified register
semantics: VEX IR omits many implicit bit truncations
and/or extensions that are part of many \ISA instruction semantics 
(i.e., these have to be emulated separately by the program), while
RockSalt's DSL uses an infinite register file instead of the finite
\ISA register file.
}
Hasabnis \etal~\cite{Hasabnis:ASPLOS16, Hasabnis:FSE16} also implement
lifting of \ISA to an architecture-independent intermediate language (IL).
In contrast with the other works above,
they use machine learning~\cite{Hasabnis:ASPLOS16} and symbolic
execution~\cite{Hasabnis:FSE16} techniques to automatically learn mappings
from \ISA instructions to IL snippets. They learn these mappings by extracting
knowledge from the hard-coded translation logic found in compilers such as GCC.
The extracted mappings cover more than 99\% of \ISA instructions. However,
\cmt{similar to the rest of binary analysis works,}
the resulting IL cannot stand as a formal \ISA definition because it
abstracts away important \ISA semantic details, e.g.,
the effect of the various instructions on CPU flags.

